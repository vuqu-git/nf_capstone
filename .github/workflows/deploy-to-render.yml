name: "Deploy nfcapstone Website"

on:
  push:
    branches:
      - main

jobs:
  build-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4 # When a workflow runs, it starts on a fresh, empty virtual machine (a runner). The checkout action is almost always the first step in a job because it's what pulls your code from the repository into the runner's filesystem. Without it, your subsequent steps (like building with Maven or running tests) would have no code to work with â†’ in simple terms, actions/checkout means copying the files from your Git repository onto the runner's temporary filesystem; more specifically, it performs a git clone operation to fetch the repository's contents

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build Frontend
        working-directory: frontend
        env:
          VITE_RECAPTCHA_SITE_KEY: ${{ secrets.VITE_RECAPTCHA_SITE_KEY }}
          #VITE_STATIC_FILEPATH: ${{ secrets.VITE_STATIC_FILEPATH }}
        run: |
          npm install
          npm run build

      - uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/dist/  # All the paths specified in the GitHub Actions YAML file refer to directories within the temporary filesystem of the runner (build server)

  build-backend:
    runs-on: ubuntu-latest
    needs: build-frontend
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: backend/src/main/resources/static

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21' # must match the version in the pom.xml
          distribution: 'temurin'
          cache: 'maven'

      - name: Build with maven
        run: mvn -B package --file backend/pom.xml

      - uses: actions/upload-artifact@v4
        with:
          name: app.jar
          path: backend/target/backend-0.0.1-SNAPSHOT.jar # must match the finalName in the pom.xml

  push-to-docker-hub:
    runs-on: ubuntu-latest
    needs: build-backend
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: app.jar
          path: backend/target

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }} # must match the name of the Dockerhub account
          password: ${{ secrets.DOCKERHUB_PASSWORD }} # must match the password of the Dockerhub account

      - name: Build and push
        uses: docker/build-push-action@v5 # This action builds a Docker image using the Dockerfile in the repository and then pushes it to the Docker Hub repository specified by the DOCKERHUB_TAG secret. The push: true option ensures the image is uploaded.
        with:
          push: true
          #tags: ${{ secrets.DOCKERHUB_TAG }} # Example: username/project:latest
          tags: vuqu/nfcapstone:v1.1.6s # Example: username/project:latest # postfix "s" in vuqu/nfcapstone:v1.X.Xs stands for static and is for VPS deployment
          context: .  # It tells the Docker builder where to find the source code and the Dockerfile it needs to build the image. The single dot (.) is a shorthand reference to the root of my repository, where the workflow is currently running. This means Docker will use the entire cloned repository as the "build context" and look for the Dockerfile within that directory.

  deploy:
    name: deploy-to-render
    runs-on: ubuntu-latest
    needs: push-to-docker-hub
    environment:  # using environment is not strictly required for a deployment job to work. You can trigger a deployment directly with a simple curl command as your final step, and it would work.
                  # However, using the environment keyword is a best practice and provides several powerful benefits that are especially important for production deployments.
      name: nfcapstone Website Project # Capstone Project name
      url: https://pupille-latest.onrender.com # Link to deployment
    steps:
      - name: Trigger Render.com Deployment
        run: |
          curl -X POST ${{ secrets.RENDER_DEPLOY }} # depoy hook: private URL to trigger a deploy
                                                    # step uses the curl command to send a POST request to a specific URL stored as a secret.
                                                    # This URL is a webhook provided by Render.com, and triggering it signals Render to pull the latest Docker image from Docker Hub and start a new deployment. This is a common method for triggering automated deployments on various cloud platforms.