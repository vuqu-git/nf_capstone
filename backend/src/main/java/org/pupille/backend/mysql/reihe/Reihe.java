package org.pupille.backend.mysql.reihe;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;

import lombok.Data;
import lombok.EqualsAndHashCode;
import org.pupille.backend.mysql.termin.Termin;

import java.util.HashSet;
import java.util.Set;

@Entity
@Data
@Table(name = "reihe")
public class Reihe {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
//    @Column(columnDefinition = "BIGINT UNSIGNED") // this is MySQL specific and does not work with H2, which is used in the integration test for Termin
    @Column
    private Long rnr;
    
    @Column(nullable = false)
    private String titel;

    @Column(columnDefinition = "TEXT")
    private String text;

    private String sonderfarbe;

    // ############################################
    // many-to-many relationship
    @ManyToMany // no cascading (Safest)
    // @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}) // safe combination (Most common)
    @JoinTable(
            name = "reihe_terminverknuepfung",
//            joinColumns = @JoinColumn(name = "rnr", columnDefinition = "BIGINT UNSIGNED"), // MySQL specific and does not work with H2
            joinColumns = @JoinColumn(name = "rnr"),
//            inverseJoinColumns = @JoinColumn(name = "tnr", columnDefinition = "BIGINT UNSIGNED") // MySQL specific and does not work with H2
            inverseJoinColumns = @JoinColumn(name = "tnr")
    )
    // No @JsonManagedReference or @JsonBackReference here for Many-to-Many-relationships if you're using JsonIgnore on the other side => Simply allow it to be serialized normally as part of Termin.
    //      Why @JsonManagedReference/@JsonBackReference is tricky for direct M-M:
    //      => These annotations are primarily designed for one-to-many/many-to-one or one-to-one relationships where one side can logically point back to a single instance of the other side.
    @JsonIgnore // <-- THIS IS THE KEY! Ignore this collection when serializing a Reihe.    // Exclude from Lombok's equals/hashCode, to avoid ConcurrentModificationException: often arises when Hibernate is trying to load or merge a collection, and the equals/hashCode methods, generated by Lombok, are inadvertently causing the collection to be "modified" (or its internal state to be accessed in a way Hibernate isn't expecting during its loading process)
    //
    // By default, @Data generates equals() and hashCode() that include all fields
    // => The Solution: Exclude Collection Fields from Lombok's equals()/hashCode()
    @EqualsAndHashCode.Exclude
    private Set<Termin> termine = new HashSet<>();
    // ############################################
}
