spring.application.name=backend

#logging.level.org.springframework.security=DEBUG

# -- secure session cookie --
#       marks the session cookie as ?Secure?, meaning the cookie will only be sent by the browser over HTTPS connections
#       improves security by preventing session cookies from being transmitted over unencrypted HTTP connections where they could be intercepted or stolen
server.servlet.session.cookie.secure=true

# -- connection to MongoDB --
spring.data.mongodb.uri=${MONGO_DB_URI}

# -- connection to MySQL db or MariaDB --
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=${DB_DRIVER}

#tells Hibernate to automatically update your database schema to match your entity models at startup,
#making it ideal for development but not for production environments
spring.jpa.hibernate.ddl-auto=update

#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
#spring.jpa.show-sql=true # Set to true for debugging


# -- connection to email server --
    #spring.mail.host=smtp.gmail.com
    #spring.mail.port=587
    #spring.mail.username=${GMAIL_MAILADDRESS}
    #spring.mail.password=${GMAIL_APPPW}
    #spring.mail.properties.mail.smtp.auth=true
    #spring.mail.properties.mail.smtp.starttls.enable=true

spring.mail.host=smtp.ionos.de
spring.mail.port=587
spring.mail.username=${IONOS_MAIL_ADDRESS}
spring.mail.password=${IONOS_MAIL_PW}
spring.mail.properties.mail.transport.protocol=smtp
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
# spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
# spring.mail.properties.mail.smtp.socketFactory.port=465
spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=5000
spring.mail.properties.mail.smtp.writetimeout=10000

# -- bcc address of contact form --
bcc.email.infoatpupille=${BCC_EMAIL_SEND_INFOATPUPILLE}

# -- oauth with github --
spring.security.oauth2.client.registration.github.client-id=${OAUTH_GITHUB_ID}
spring.security.oauth2.client.registration.github.client-secret=${OAUTH_GITHUB_SECRET}
spring.security.oauth2.client.registration.github.scope=none

# list of approved GitHub users: exact GitHub usernames (case-sensitive)
#oauth.approved.github.users=
oauth.approved.github.users=${OAUTH_APPROVED_GITHUB_USERS}

# Your existing app URL for successful login
oauth.appurl=${OAUTH_APPURL}
#oauth.appurl=http://localhost:5173

# New property for authentication error redirection on the frontend
oauth.errorurl=${OAUTH_ERRORURL}
#oauth.errorurl=http://localhost:5173/login

# -- google recaptcha secrect key --
recaptcha.secret.key=${RECAPTCHA_SECRET_KEY}

# -- static files path for mount binding in docker container --
#                                                                            : colon separates the variable name from the default value
static.files.path.for.dockercontainer=${STATIC_FILES_PATH_FOR_DOCKERCONTAINER:/app/external-static-container/static-files/}
#LEFT value in volume mapping:
    # value syntax for LOCAL testing: C:\Daten\dcTestdc\
    # value syntax for prod on VPS: /var/www/vhosts/epic-hypatia.XXX-XXX-XXX-XXX.plesk.page/pupille-website/external-static-container/static-files/     # this is where plesk file manager stores the files

#RIGHT value in volume mapping:
    # /app/external-static-container/static-files/

# ==> http://localhost:1234/static-files/[anyfolder or anyfiles]

#############################################################################
#spring.web.resources.static-locations=file:/app/static-files/

# What does spring.web.resources.static-locations=file:/app/static-files/ do?
# This tells Spring to serve static files from /app/static-files/ on the file system where the files will live (in our case the docker container?s file system)
# Spring will serve static files from this external folder on the file system at runtime, outside of your packaged application
# This means /app/static-files/ is typically a directory mounted as a volume or bind mount from your host (where the files actually exist) into the container.
#   If you use classpath-based serving, then the static files go into your Maven resources folder and are bundled into the jar at build time. But with file-based locations (like here the case), they live outside the built application.

# BIG BUT:
# ~~~~~~~
# This property completely REPLACES Spring Boot's default static resource locations with your custom location.
# Default locations (when you don't set this property):
# classpath:/static/
# classpath:/public/
# classpath:/resources/
# classpath:/META-INF/resources/

# ? After setting your property:
# Only file:/app/static-files/ is used; All default locations are ignored

# Does it add an additional place? NO! This is a common misconception. The property replaces the defaults, it doesn't add to them.
# If you want to add an additional location while keeping the defaults, you have two options:
# Option A: Keep defaults + add your location
#           spring.web.resources.static-locations=classpath:/static/,classpath:/public/,classpath:/resources/,classpath:/META-INF/resources/,file:/app/static-files/

# Option B: Use Java configuration (recommended)
#           SPAConfiguration implements WebMvcConfigurer:
#           public void addResourceHandlers(ResourceHandlerRegistry registry) {
#           registry.addResourceHandler("/**")
#               .addResourceLocations(
#               ...
#               )