spring.application.name=backend

#logging.level.org.springframework.security=DEBUG

# -- secure session cookie --
#       marks the session cookie as ?Secure?, meaning the cookie will only be sent by the browser over HTTPS connections
#       improves security by preventing session cookies from being transmitted over unencrypted HTTP connections where they could be intercepted or stolen
server.servlet.session.cookie.secure=true

# *** ***
# Security Hardening, add these to prevent Cross-Site Scripting (XSS) and Session Hijacking:
# Prevents JS from accessing the session cookie
server.servlet.session.cookie.http-only=true

# Restricts cookie sending to same-site requests (prevents CSRF)
#server.servlet.session.cookie.same-site=strict
    # When a cookie is set to Strict, the browser will REFUSE to send it in any request that it considers "cross-site" or even some types of navigation.
    # Even though you are proxying, the browser sees the initial OAuth2 redirect coming from GitHub (a different site) back to your app. While your Proxy makes API calls look like they are same-origin, the initial cookie creation happened during a redirect chain.

# lax is the industry standard default for modern web applications
server.servlet.session.cookie.same-site=lax
# *** ***

# -- connection to MongoDB --
spring.data.mongodb.uri=${MONGO_DB_URI}

# -- connection to MySQL db or MariaDB --
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=${DB_DRIVER}

# *** ***
# tells Hibernate to automatically update your database schema to match your entity models at startup,
# making it ideal for development but not for production environments
spring.jpa.hibernate.ddl-auto=update

# Production Recommendation:
# Only validates that the schema matches the entities; does not change data
#spring.jpa.hibernate.ddl-auto=validate

# OR set to 'none' if you manage migrations manually
# spring.jpa.hibernate.ddl-auto=none
# *** ***

#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
#spring.jpa.show-sql=true # Set to true for debugging

# -- connection to email server --
    #spring.mail.host=smtp.gmail.com
    #spring.mail.port=587
    #spring.mail.username=${GMAIL_MAILADDRESS}
    #spring.mail.password=${GMAIL_APPPW}
    #spring.mail.properties.mail.smtp.auth=true
    #spring.mail.properties.mail.smtp.starttls.enable=true

spring.mail.host=smtp.ionos.de
spring.mail.port=587
spring.mail.username=${IONOS_MAIL_ADDRESS}
spring.mail.password=${IONOS_MAIL_PW}
spring.mail.properties.mail.transport.protocol=smtp
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
# spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
# spring.mail.properties.mail.smtp.socketFactory.port=465
spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=5000
spring.mail.properties.mail.smtp.writetimeout=10000

# -- bcc address of contact form --
bcc.email.infoatpupille=${BCC_EMAIL_SEND_INFOATPUPILLE}

# -- oauth with github --
spring.security.oauth2.client.registration.github.client-id=${OAUTH_GITHUB_ID}
spring.security.oauth2.client.registration.github.client-secret=${OAUTH_GITHUB_SECRET}

# *** ***
# If the scope is none, GitHub only sends back Public Profile data.
    # => Missing Data: If a user has a highly restrictive privacy setting on GitHub, their login (username) or email might return as null to your application because you didn't ask for permission to see them.
    # => Check with "Approved Users" list doesn't work reliably
#spring.security.oauth2.client.registration.github.scope=none

# Provides the username and profile data reliably
    # If you verify by Username: Use read:user. This ensures that even if a user has a private profile, your app can still "see" their username to compare it against your list.
    # If you verify by Email: Use user:email. Most GitHub users keep their email private. Without this scope, your backend will almost always see email: null, making it impossible to verify them.
spring.security.oauth2.client.registration.github.scope=read:user,user:email
# *** ***

# list of approved GitHub users: exact GitHub usernames (case-sensitive)
oauth.approved.github.users=${OAUTH_APPROVED_GITHUB_USERS}

# Your existing app URL for successful login
oauth.appurl=${OAUTH_APPURL}
#oauth.appurl=http://localhost:5173/dmn

# New property for authentication error redirection on the frontend
oauth.errorurl=${OAUTH_ERRORURL}
#oauth.errorurl=http://localhost:5173/lgn

# -- google recaptcha secrect key --
recaptcha.secret.key=${RECAPTCHA_SECRET_KEY}

# -- cache static files for 1 year --
# Since static files from a Docker mount are served, tell the browser to cache them so they don't reload on every click
spring.web.resources.cache.period=31536000

# -- static files path for mount binding in docker container --
#                                                                            : colon separates the variable name from the default value
static.files.path.for.dockercontainer=${STATIC_FILES_PATH_FOR_DOCKERCONTAINER:/app/external-static-container/static-files/}
#LEFT value in volume mapping:
    # value syntax for LOCAL testing: C:\Daten\dcTestdc\
    # value syntax for prod on VPS: /var/www/vhosts/epic-hypatia.XXX-XXX-XXX-XXX.plesk.page/pupille-website/external-static-container/static-files/     # this is where plesk file manager stores the files

#RIGHT value in volume mapping:
    # /app/external-static-container/static-files/

# ==> http://localhost:1234/static-files/[anyfolder or anyfiles]

#############################################################################
#spring.web.resources.static-locations=file:/app/static-files/

# What does spring.web.resources.static-locations=file:/app/static-files/ do?
# This tells Spring to serve static files from /app/static-files/ on the file system where the files will live (in our case the docker container?s file system)
# Spring will serve static files from this external folder on the file system at runtime, outside of your packaged application
# This means /app/static-files/ is typically a directory mounted as a volume or bind mount from your host (where the files actually exist) into the container.
#   If you use classpath-based serving, then the static files go into your Maven resources folder and are bundled into the jar at build time. But with file-based locations (like here the case), they live outside the built application.

# BIG BUT:
# ~~~~~~~
# This property completely REPLACES Spring Boot's default static resource locations with your custom location.
# Default locations (when you don't set this property):
# classpath:/static/
# classpath:/public/
# classpath:/resources/
# classpath:/META-INF/resources/

# ? After setting your property:
# Only file:/app/static-files/ is used; All default locations are ignored

# Does it add an additional place? NO! This is a common misconception. The property replaces the defaults, it doesn't add to them.
# If you want to add an additional location while keeping the defaults, you have two options:
# Option A: Keep defaults + add your location
#           spring.web.resources.static-locations=classpath:/static/,classpath:/public/,classpath:/resources/,classpath:/META-INF/resources/,file:/app/static-files/

# Option B: Use Java configuration (recommended)
#           SPAConfiguration implements WebMvcConfigurer:
#           public void addResourceHandlers(ResourceHandlerRegistry registry) {
#           registry.addResourceHandler("/**")
#               .addResourceLocations(
#               ...
#               )