package org.pupille.backend.mysql.reihe;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.pupille.backend.mysql.termin.Termin;
import org.pupille.backend.mysql.termin.TerminRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.oidcLogin;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import org.springframework.http.MediaType;

import java.time.LocalDateTime;
import java.util.NoSuchElementException;

@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureMockMvc
class ReiheControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    // to perform CRUD operations on the ReiheRepository as H2 in-memory relational DB
    @Autowired
    private ReiheRepository reiheRepository;
    // to perform CRUD operations on the TerminRepository as H2 in-memory relational DB
    @Autowired
    private TerminRepository terminRepository;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {   // Clean the tables before each test
        reiheRepository.deleteAll();
        terminRepository.deleteAll();
    }

    @Test
    void testGetAllReihen_returnsList() throws Exception {
        Reihe r1 = new Reihe();
        r1.setTitel("Titel 1");
        r1 = reiheRepository.save(r1);
        // through DB table autoincrement the rnr of r1 is 1

        mockMvc.perform(get("/api/reihe"))
                .andExpect(status().isOk())
                                //$: This symbol represents the root of the JSON document: it refers to the entire JSON response.
                                //[0]: This is an array index. It refers to the first element in the JSON array. In this case, it means the test is checking the first object in the array returned by the API.
                                //.rnr: This is a field within the JSON object. It refers to the rnr property of the first object in the array.
                .andExpect(jsonPath("$[0].rnr").value(r1.getRnr()))
                .andExpect(jsonPath("$[0].titel").value("Titel 1"));
    }

    @Test
    void testGetReiheDTOFormByIdWithTermineAndFilms_returnsStructuredDTO() throws Exception {
        Reihe r = new Reihe();
        r.setTitel("Reihe mit Details");
        r = reiheRepository.save(r);

        // through DB table autoincrement the rnr of r is 1
        System.out.println(r.getRnr());

        mockMvc.perform(get("/api/reihe/" + r.getRnr()))
                .andExpect(status().isOk())
//                .andExpect(jsonPath("$.rnr").exists())
                .andExpect(jsonPath("$.rnr").value(r.getRnr()))
                .andExpect(jsonPath("$.titel").value("Reihe mit Details"))
                .andExpect(jsonPath("$.termine").isArray());
    }

    @Test
    void testCreateAndGetReihe() throws Exception {
        Reihe reihe = new Reihe();
        reihe.setTitel("Test Reihe");
        reihe.setText("Test Text Reihe");
        reihe.setSonderfarbe("pupille-glow");

        mockMvc.perform(post("/api/reihe")
                        .contentType(MediaType.APPLICATION_JSON)
                // objectMapper: This is an instance of ObjectMapper from the Jackson library, which is used for converting Java objects to JSON and vice versa.
                // writeValueAsString(reihe): This method converts the reihe object into a JSON string. The ObjectMapper serializes the reihe object into a JSON format.
                // .content(...): This method sets the body of the HTTP request to the JSON string generated by objectMapper.writeValueAsString(reihe).
                        .content(objectMapper.writeValueAsString(reihe))
                        .with(oidcLogin().userInfoToken(token -> token.claim("login", "github-username"))))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.rnr").exists())
                .andExpect(jsonPath("$.titel").value("Test Reihe"))
                .andReturn().getResponse().getContentAsString();

        Reihe createdReihe = reiheRepository.findAll().get(0);

        mockMvc.perform(get("/api/reihe/" + createdReihe.getRnr()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.titel").value("Test Reihe"));
    }

    @Test
    void testUpdateReihe_modifiesReihe() throws Exception {
        Reihe r = new Reihe();
        r.setTitel("Alt");
        r = reiheRepository.save(r);

        String updated = """
        {
          "titel": "Neu",
          "text": "Überarbeitet"
        }
    """;

        mockMvc.perform(put("/api/reihe/" + r.getRnr())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(updated)
                        .with(oidcLogin().userInfoToken(token -> token.claim("login", "github-username"))))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.titel").value("Neu"));
    }

    @Test
    void testDeleteReihe_removesReihe() throws Exception {
        Reihe r = new Reihe();
        r.setTitel("Zum Löschen");
        r = reiheRepository.save(r);

        mockMvc.perform(delete("/api/reihe/" + r.getRnr())
                        .with(oidcLogin().userInfoToken(token -> token.claim("login", "github-username"))))
                .andExpect(status().isNoContent());

        assertFalse(reiheRepository.findById(r.getRnr()).isPresent());
    }

    @Test
    void testGetAllReihenByTerminId_returnsList() throws Exception {
        Termin termin = new Termin();
        termin.setVorstellungsbeginn(LocalDateTime.now());
        termin.setTitel("Test Termin");
        termin = terminRepository.save(termin);

        Reihe reihe = new Reihe();
        reihe.setTitel("Test Reihe");

        reihe.getTermine().add(termin); // associate Termin with Reihe
        reiheRepository.save(reihe);

        // in bidirectional relationship, you need to ensure that both sides of the relationship are updated
        // though here for testing not required
        termin.getReihen().add(reihe); // add the association also from the Termin side
        terminRepository.save(termin); // save the Termin to persist the association

        Long terminId = termin.getTnr();

        mockMvc.perform(get("/api/reihe/getreihen-fromtermin/" + terminId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$").isArray())
                .andExpect(jsonPath("$[0].titel").value("Test Reihe"));
    }

    @Test
    void testAddTerminToReihe_addsSuccessfully() throws Exception {
        Reihe r = new Reihe();
        r.setTitel("Add Termin Reihe");
        r = reiheRepository.save(r);

        Termin t = new Termin();
        t.setTitel("Termin to Add");
        t.setVorstellungsbeginn(LocalDateTime.now());
        t = terminRepository.save(t);

        mockMvc.perform(post("/api/reihe/" + r.getRnr() + "/termin/" + t.getTnr())
                        .with(oidcLogin().userInfoToken(token -> token.claim("login", "github-username"))))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.rnr").value(r.getRnr()))
                .andExpect(jsonPath("$.titel").value("Add Termin Reihe"))
                // the 3 following code lines make the test fail: java.lang.AssertionError: No value at JSON path "$.termine"
                // because of the @JsonIgnore for field termine in Reihe entity class
                // thus, verify the relationship in the database (see below)
//                .andExpect(jsonPath("$.termine").isArray())
//                .andExpect(jsonPath("$.termine[0].tnr").value(t.getTnr()))
//                .andExpect(jsonPath("$.termine[0].titel").value("Termin to Add"))
                ;

        // -- verify the established relationship in the database --
                                            // important here to use the repo method where the relating field is eagerly fetched!
        Reihe updatedReihe = reiheRepository.findWithTermineByRnr(r.getRnr()).orElseThrow();
        assertEquals(1, updatedReihe.getTermine().size());

        // fetch the inserted Termin from the repository and verify values
        Termin finalT = t; // t is the one from above
        Termin insertedTermin = updatedReihe.getTermine().stream()
                .filter(terminArg -> terminArg.getTnr().equals(finalT.getTnr()))
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("Inserted Termin not found"));

        assertEquals(t.getTnr(), insertedTermin.getTnr(), "The tnr of the inserted Termin should match");
        assertEquals("Termin to Add", insertedTermin.getTitel(), "The titel of the inserted Termin should match");

        // - verify the relationship from the Termin side -
                                            // important here to use the repo method where the relating field is eagerly fetched!
        Termin updatedTermin = terminRepository.findWithReihenByTnr(t.getTnr()).orElseThrow();
        assertEquals(1, updatedTermin.getReihen().size());

        // fetch the inserted Reihe from the repository and verify values
        Reihe finalR = r; // r is the one from above
        Reihe insertedReihe = updatedTermin.getReihen().stream()
                .filter(reiheArg -> reiheArg.getRnr().equals(finalR.getRnr()))
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("Inserted Reihe not found"));

        assertEquals(r.getRnr(), insertedReihe.getRnr(), "The rnr of the inserted Reihe should match");
        assertEquals("Add Termin Reihe", insertedReihe.getTitel(), "The titel of the inserted Reihe should match");
    }

    @Test
    void testRemoveTerminFromReihe_removesSuccessfully() throws Exception {
        Reihe r = new Reihe();
        r.setTitel("Remove Termin Reihe");
        r = reiheRepository.save(r);

        Termin t = new Termin();
        t.setTitel("Termin to Remove");
        t.setVorstellungsbeginn(LocalDateTime.now());
        t = terminRepository.save(t);

        // Associate Termin with Reihe before removing it
        r.getTermine().add(t);
        r = reiheRepository.save(r);

        // Make the association bidirectional
        t.getReihen().add(r);
        t = terminRepository.save(t);

        mockMvc.perform(delete("/api/reihe/" + r.getRnr() + "/termin/" + t.getTnr())
                        .with(oidcLogin().userInfoToken(token -> token.claim("login", "github-username"))))
                .andExpect(status().isNoContent());

        // Verify the relationship has been removed from the database
                                            // important here to use the repo methods where the relating field is eagerly fetched!
        Reihe updatedReihe = reiheRepository.findWithTermineByRnr(r.getRnr()).orElseThrow();
        Termin updatedTermin = terminRepository.findWithReihenByTnr(t.getTnr()).orElseThrow();

        assertFalse(updatedReihe.getTermine().contains(updatedTermin));
        assertFalse(updatedTermin.getReihen().contains(updatedReihe));
    }

}
